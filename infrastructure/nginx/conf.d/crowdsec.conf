############################################################################
# CrowdSec Integration for NGINX
# WAF/IDS Protection via CrowdSec Bouncer
# Container: 423 (zentoria-waf)
# Updated: 2026-01-16
############################################################################

# CrowdSec Bouncer Connection
# This configuration integrates with CrowdSec running in container 423
# The bouncer communicates with CrowdSec API to check if requests should be blocked

# Include CrowdSec Lua module (installed via docker-compose)
# lua_package_path "/etc/nginx/crowdsec/?.lua;;";

# Uncomment below to enable CrowdSec protection
# The bouncer runs as a separate process and communicates via HTTP to NGINX

# Map for CrowdSec decisions
map $remote_addr $crowdsec_decision {
    default "ALLOW";
    # Decisions are populated by CrowdSec bouncer
    # This map gets updated by external process
}

# Alternative: Using CrowdSec NGINX connector via Lua
# This approach uses Lua to call CrowdSec API directly
# Slightly more integrated but requires Lua module

# lua_shared_dict crowdsec_cache 10m;
# lua_shared_dict crowdsec_decisions 10m;

# init_by_lua_block {
#     crowdsec = require("crowdsec")
#     crowdsec.init({
#         bouncer_url = "http://zentoria-waf:6000",
#         bouncer_key = "${CROWDSEC_BOUNCER_KEY}",
#         cache_ttl = 3600,
#         log_level = "info"
#     })
# }

# access_by_lua_block {
#     local crowdsec = require("crowdsec")
#     local decision = crowdsec.get_decision(ngx.var.remote_addr)
#
#     if decision == "ban" then
#         return ngx.HTTP_FORBIDDEN
#     elseif decision == "captcha" then
#         -- Handle CAPTCHA challenge
#         return ngx.HTTP_TEMPORARY_REDIRECT
#     end
# }

############################################################################
# CrowdSec NGINX Connector (Simpler HTTP-based approach)
# This uses CrowdSec's official NGINX bouncer
############################################################################

# Enable CrowdSec logging
log_format crowdsec_format '$remote_addr - [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for" '
                          'crowdsec_decision="$crowdsec_decision"';

# Cache for CrowdSec decisions (reduce API calls)
proxy_cache_path /var/cache/nginx/crowdsec levels=1:2 keys_zone=crowdsec_cache:10m max_size=100m inactive=60m;

# Map for internal IPs that bypass CrowdSec
map $remote_addr $skip_crowdsec {
    default 0;
    127.0.0.1 1;
    ::1 1;
    10.0.0.0/8 1;
    172.16.0.0/12 1;
    192.168.0.0/16 1;
}

############################################################################
# CrowdSec Attack Patterns
# These patterns are used with built-in rules to detect attacks
############################################################################

# Common attack patterns to log for CrowdSec analysis
map $uri $attack_pattern {
    default "normal";
    ~*\.\./ "path_traversal";
    ~*(\?|%3F).*=.*(%27|%22|%3D) "sql_injection";
    ~*<script|javascript:|onerror= "xss_attack";
    ~*/admin/|/wp-admin/ "admin_scan";
    ~*/\.git/|/\.env|/config\.php "sensitive_scan";
    ~*\.php\?.*id=|union.*select "sqli_pattern";
}

# Log attack patterns for CrowdSec
access_log /var/log/nginx/crowdsec-attacks.log security if=$attack_pattern;

############################################################################
# CrowdSec Scenarios & Decisions
# These would be configured in CrowdSec container
############################################################################

# Example scenarios that CrowdSec detects:
# - http-path-traversal: Detects path traversal attempts
# - http-sqli: SQL injection patterns
# - http-xss: Cross-site scripting attempts
# - http-cve-*: Known CVE exploitation attempts
# - ssh-bruteforce: SSH connection attempts
# - http-generic-client: Generic client reconnaissance
# - http-slow-read: Slow read DDoS attacks
# - http-win-ms-exchange: MS Exchange vulnerabilities
# - http-web-shell: Web shell upload detection

############################################################################
# CrowdSec Whitelist
# IPs/CIDRs that are always allowed
############################################################################

# Whitelist configuration
set $crowdsec_whitelist 0;

if ($remote_addr ~* ^(127\.0\.0\.1|::1|10\.|172\.1[6-9]\.|172\.2[0-9]\.|172\.3[01]\.|192\.168\.)$) {
    set $crowdsec_whitelist 1;
}

# Whitelist search engines
if ($http_user_agent ~* (googlebot|bingbot|slurp|duckduckbot|baiduspider)) {
    set $crowdsec_whitelist 1;
}

############################################################################
# CrowdSec Configuration for Production
############################################################################

# To enable CrowdSec protection:
#
# 1. Install CrowdSec in container 423:
#    docker run -d --name zentoria-waf \
#      -p 6000:6000 \
#      -e BOUNCER_KEY=your_bouncer_key \
#      crowdsecurity/crowdsec:latest
#
# 2. Register bouncer:
#    docker exec zentoria-waf cscli bouncer add nginx-bouncer
#
# 3. Configure NGINX bouncer:
#    docker run -d --name nginx-bouncer \
#      -e BOUNCER_URL=http://zentoria-waf:6000 \
#      -e BOUNCER_KEY=your_bouncer_key \
#      -e PROTECTED_PATHS=/api,/admin \
#      crowdsecurity/nginx-bouncer:latest
#
# 4. Update NGINX directives to call bouncer
#
# 5. Monitor decisions:
#    docker exec zentoria-waf cscli decisions list
#
# 6. View logs:
#    docker logs zentoria-waf
#    tail -f /var/log/nginx/crowdsec-attacks.log

############################################################################
# Manual Ban/Allow Rules (Alternative to CrowdSec)
############################################################################

# If not using CrowdSec, these manual rules can block known attack patterns

# Block common exploit attempts
location ~ /\. {
    deny all;
    access_log /var/log/nginx/blocked-requests.log security;
}

location ~ ~\.php$ {
    deny all;
    access_log /var/log/nginx/blocked-requests.log security;
}

# Block suspicious user agents
if ($http_user_agent ~* (nikto|sqlmap|sqlninja|acunetix|nessus|masscan|zap)) {
    return 403;
}

# Block requests with suspicious patterns in query string
if ($query_string ~* (<|%3C).*script.*(>|%3E)) {
    return 403;
}

if ($query_string ~* union.*select|union.*from) {
    return 403;
}

if ($query_string ~* concat.*char) {
    return 403;
}

############################################################################
# Rate Limiting with CrowdSec Integration
# Coordinate with CrowdSec for distributed rate limit enforcement
############################################################################

# High rate = automatic CrowdSec alert
# Configure in CrowdSec scenarios to ban if rate exceeds threshold

# Example: Rate limit with CrowdSec feedback
map $status $request_count {
    default 1;
    429 2;  # Increased weight for rate limit responses
}

# Log rate limit decisions for CrowdSec
access_log /var/log/nginx/crowdsec-ratelimit.log security if=$request_count;
